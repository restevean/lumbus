extern crate cocoa;
extern crate core_graphics;
extern crate objc;

use cocoa::appkit::{
    NSApp, NSApplication, NSColor, NSPanel, NSWindowCollectionBehavior, NSWindowStyleMask,
    NSBackingStoreType,
};
use cocoa::appkit::NSWindow; // IMPORTANTE: Trae a alcance los métodos definidos en el trait NSWindow.
use cocoa::base::{id, nil, YES, NO};
use cocoa::foundation::{NSPoint, NSRect, NSSize};
use core_graphics::display::CGDisplay;
use core_graphics::event::CGEvent;
use core_graphics::event_source::{CGEventSource, CGEventSourceStateID};
use objc::runtime::{Class, Object, Sel};
use objc::{declare::ClassDecl, msg_send, sel, sel_impl};

// Dimensiones del círculo
const CIRCLE_DIAMETER: f64 = 38.5;
const BORDER_WIDTH: f64 = 3.0;

// Almacenamos la posición del cursor
static mut CURSOR_POS: (f64, f64) = (0.0, 0.0);

fn main() {
    unsafe {
        // Inicializamos la aplicación
        let app = NSApp();
        app.setActivationPolicy_(cocoa::appkit::NSApplicationActivationPolicy::NSApplicationActivationPolicyRegular);

        // Obtenemos las pantallas activas
        let displays = CGDisplay::active_displays().unwrap();
        let total_width: f64 = displays
            .iter()
            .map(|&id| CGDisplay::new(id).bounds().size.width)
            .sum();
        let max_height: f64 = displays
            .iter()
            .map(|&id| CGDisplay::new(id).bounds().size.height)
            .max_by(|a, b| a.partial_cmp(b).unwrap())
            .unwrap();

        // Creamos la ventana sin bordes y del tamaño de todas las pantallas usando NSPanel
        // Usamos initWithContentRect_styleMask_backing_defer_screen_ (pasando nil como pantalla)
        let window = NSPanel::alloc(nil).initWithContentRect_styleMask_backing_defer_screen_(
            NSRect::new(NSPoint::new(0.0, 0.0), NSSize::new(total_width, max_height)),
            NSWindowStyleMask::NSBorderlessWindowMask,
            NSBackingStoreType::NSBackingStoreBuffered,
            NO,
            nil
        );

        // Configuración de la ventana para que se muestre en todas las pantallas
        window.setOpaque_(NO);
        window.setBackgroundColor_(NSColor::clearColor(nil));
        window.setIgnoresMouseEvents_(YES);

        // Elevamos el nivel de la ventana para que se muestre sobre otras (incluido pantalla completa)
        window.setLevel_(1000.into());

        // Configuramos la ventana para que esté en todos los espacios y en pantalla completa,
        // agregando también IgnoresCycle para evitar que se incluya en el ciclo de ventanas.
        window.setCollectionBehavior_(
            NSWindowCollectionBehavior::NSWindowCollectionBehaviorCanJoinAllSpaces
            | NSWindowCollectionBehavior::NSWindowCollectionBehaviorFullScreenAuxiliary
            | NSWindowCollectionBehavior::NSWindowCollectionBehaviorStationary
            | NSWindowCollectionBehavior::NSWindowCollectionBehaviorIgnoresCycle
        );

        // Usamos el frame completo de la ventana para la vista
        let window_frame: NSRect = msg_send![window, frame];
        let view: id = register_custom_view_class(window, window_frame);

        // Usamos NSTimer para actualizar la posición del cursor cada 16 ms (aprox. 60 FPS)
        let _: id = create_timer(view, sel!(update_cursor), 0.016);

        app.run(); // Ejecuta la aplicación
    }
}

/// Registrar la clase personalizada de la vista utilizando el frame completo de la ventana
unsafe fn register_custom_view_class(window: id, frame: NSRect) -> id {
    let superclass = Class::get("NSView").unwrap();
    let mut decl = ClassDecl::new("CustomView", superclass).unwrap();

    // Método que actualizará la posición del cursor
    extern "C" fn update_cursor(this: &Object, _cmd: Sel) {
        unsafe {
            let cursor_pos = get_mouse_position();
            CURSOR_POS = cursor_pos;
            let _: () = msg_send![this, setNeedsDisplay: YES]; // Fuerza el redibujo
        }
    }

    // Método para dibujar el círculo
    extern "C" fn draw_rect(_this: &Object, _cmd: Sel, _rect: NSRect) {
        unsafe {
            let (x, y) = CURSOR_POS;

            // Invertimos la coordenada Y para alinear correctamente el dibujo
            let screen_height = CGDisplay::main().bounds().size.height;
            let adjusted_y = screen_height - y;

            let radius = CIRCLE_DIAMETER / 2.0;
            let rect = NSRect::new(
                NSPoint::new(x - radius, adjusted_y - radius),
                NSSize::new(CIRCLE_DIAMETER, CIRCLE_DIAMETER),
            );

            // Obtener la ruta de dibujo y configurar el color (borde blanco)
            let circle: id = msg_send![Class::get("NSBezierPath").unwrap(), bezierPathWithOvalInRect: rect];
            let _: () = msg_send![circle, setLineWidth: BORDER_WIDTH];
            let color: id = msg_send![Class::get("NSColor").unwrap(), whiteColor];
            let _: () = msg_send![color, set];
            let _: () = msg_send![circle, stroke];
        }
    }

    // Añadir los métodos a la clase
    decl.add_method(sel!(update_cursor), update_cursor as extern "C" fn(&Object, Sel));
    decl.add_method(sel!(drawRect:), draw_rect as extern "C" fn(&Object, Sel, NSRect));

    let new_class = decl.register();

    // Crear la vista personalizada usando el frame completo de la ventana
    let view: id = msg_send![new_class, alloc];
    let view: id = msg_send![view, initWithFrame: frame];
    let _: () = msg_send![window, setContentView: view];
    let _: () = msg_send![window, makeKeyAndOrderFront: nil];

    view
}

/// Crear un temporizador NSTimer que llama al método indicado en intervalos regulares
unsafe fn create_timer(target: id, selector: Sel, interval: f64) -> id {
    let timer_class = Class::get("NSTimer").unwrap();
    let timer: id = msg_send![timer_class,
        scheduledTimerWithTimeInterval: interval
        target: target
        selector: selector
        userInfo: nil
        repeats: YES
    ];
    timer
}

/// Obtiene la posición actual del ratón en la pantalla
fn get_mouse_position() -> (f64, f64) {
    let event_source = CGEventSource::new(CGEventSourceStateID::HIDSystemState).unwrap();
    let event = CGEvent::new(event_source).unwrap();
    let location = event.location();
    (location.x, location.y)
}
