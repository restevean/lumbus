#![allow(unexpected_cfgs)] // Silencia warnings de cfg dentro de macros de objc/cocoa

use block::ConcreteBlock;
use cocoa::appkit::{
    NSApp, NSApplication, NSApplicationActivationPolicy, NSBackingStoreType, NSColor, NSEventType,
    NSWindow, NSWindowCollectionBehavior, NSWindowStyleMask,
};
use cocoa::base::{id, nil, NO, YES};
use cocoa::foundation::{NSAutoreleasePool, NSArray, NSPoint, NSRect, NSSize};
use objc::runtime::{Class, Object, Sel};
use objc::{class, declare::ClassDecl, msg_send, sel, sel_impl};

// Apariencia del círculo
const CIRCLE_DIAMETER: f64 = 38.5;
const BORDER_WIDTH: f64 = 3.0;

fn main() {
    unsafe {
        let _pool = NSAutoreleasePool::new(nil);

        let app = NSApp();
        // La app no toma foco (evita beep e interferencias)
        app.setActivationPolicy_(NSApplicationActivationPolicy::NSApplicationActivationPolicyProhibited);

        // --- Unión de todas las pantallas (Cocoa / NSScreen) ---
        let (min_x, min_y, union_width, union_height) = union_de_pantallas_cocoa();

        // Ventana transparente, sin bordes, que cubre la unión de pantallas (Cocoa coords)
        let window = NSWindow::alloc(nil).initWithContentRect_styleMask_backing_defer_(
            NSRect::new(
                NSPoint::new(min_x, min_y),
                NSSize::new(union_width, union_height),
            ),
            NSWindowStyleMask::NSBorderlessWindowMask,
            NSBackingStoreType::NSBackingStoreBuffered,
            NO,
        );
        window.setOpaque_(NO);
        window.setBackgroundColor_(NSColor::clearColor(nil));
        window.setIgnoresMouseEvents_(YES);
        window.setLevel_((nspop_up_menu_window_level() + 1).into());
        window.setCollectionBehavior_(
            NSWindowCollectionBehavior::NSWindowCollectionBehaviorCanJoinAllSpaces
                | NSWindowCollectionBehavior::NSWindowCollectionBehaviorFullScreenAuxiliary
                | NSWindowCollectionBehavior::NSWindowCollectionBehaviorStationary,
        );

        // Vista personalizada con estado y monitor retenido
        let view: id = register_custom_view_class_and_create_view(window, union_width, union_height);

        // Timer a ~60 FPS para actualizar coordenadas y repintar (vista completa)
        let _: id = create_timer(view, sel!(update_cursor), 0.016);

        // Monitor global de teclado: CTRL + A -> alterna visibilidad
        install_global_key_monitor(view);

        // Mostrar sin hacerla key (no toma foco)
        let _: () = msg_send![window, orderFrontRegardless];

        app.run();
    }
}

/// Nivel por encima de menús contextuales (aproximado)
fn nspop_up_menu_window_level() -> i64 {
    201
}

/// Construye una máscara de evento a partir de un NSEventType (equivalente a NSEventMaskFromType)
#[inline]
fn mask_from_event_type(ty: NSEventType) -> u64 {
    1u64 << (ty as u64)
}

/// Unión de pantallas usando NSScreen (Cocoa coords: origen abajo-izquierda)
unsafe fn union_de_pantallas_cocoa() -> (f64, f64, f64, f64) {
    let screens: id = msg_send![class!(NSScreen), screens];
    let count: usize = msg_send![screens, count];

    let mut min_x = f64::INFINITY;
    let mut min_y = f64::INFINITY;
    let mut max_x = f64::NEG_INFINITY;
    let mut max_y = f64::NEG_INFINITY;

    for i in 0..count {
        let screen: id = msg_send![screens, objectAtIndex: i];
        let frame: NSRect = msg_send![screen, frame];
        min_x = min_x.min(frame.origin.x);
        min_y = min_y.min(frame.origin.y);
        max_x = max_x.max(frame.origin.x + frame.size.width);
        max_y = max_y.max(frame.origin.y + frame.size.height);
    }

    let union_width = (max_x - min_x).max(1.0);
    let union_height = (max_y - min_y).max(1.0);
    (min_x, min_y, union_width, union_height)
}

/// Posición del ratón en coordenadas **Cocoa** (pantalla)
fn get_mouse_position_cocoa() -> (f64, f64) {
    unsafe {
        let cls = class!(NSEvent);
        let p: NSPoint = msg_send![cls, mouseLocation];
        (p.x, p.y)
    }
}

/// Registra `CustomView` y crea la instancia (estado sencillo, sin filtros)
unsafe fn register_custom_view_class_and_create_view(window: id, width: f64, height: f64) -> id {
    let class_name = "CustomView";
    let custom_view_class = if let Some(cls) = Class::get(class_name) {
        cls
    } else {
        let superclass = Class::get("NSView").unwrap();
        let mut decl = ClassDecl::new(class_name, superclass).unwrap();

        // Ivars de estado (posición pantalla) y retención de monitor de teclado
        decl.add_ivar::<f64>("_cursorXScreen");
        decl.add_ivar::<f64>("_cursorYScreen");
        decl.add_ivar::<bool>("_visible");
        decl.add_ivar::<id>("_keyMonitor");

        // Método: actualiza posición del cursor (Cocoa) y repinta vista completa
        extern "C" fn update_cursor(this: &mut Object, _cmd: Sel) {
            unsafe {
                let (x, y) = get_mouse_position_cocoa();
                *this.get_mut_ivar::<f64>("_cursorXScreen") = x;
                *this.get_mut_ivar::<f64>("_cursorYScreen") = y;
                let _: () = msg_send![this, setNeedsDisplay: YES]; // repinta todo -> sin “rastros”
            }
        }

        // Método: alterna visibilidad y repinta
        extern "C" fn toggle_visibility(this: &mut Object, _cmd: Sel) {
            unsafe {
                let vis = *this.get_ivar::<bool>("_visible");
                *this.get_mut_ivar::<bool>("_visible") = !vis;
                // Pinta inmediatamente al mostrar (sin esperar al siguiente tick)
                if !vis {
                    let _: () = msg_send![this, performSelectorOnMainThread: sel!(update_cursor) withObject: nil waitUntilDone: NO];
                } else {
                    let _: () = msg_send![this, setNeedsDisplay: YES];
                }
            }
        }

        // Dibuja el círculo convertiendo **pantalla → ventana → vista** (Cocoa coords)
        extern "C" fn draw_rect(this: &Object, _cmd: Sel, _rect: NSRect) {
            unsafe {
                let sx = *this.get_ivar::<f64>("_cursorXScreen");
                let sy = *this.get_ivar::<f64>("_cursorYScreen");
                let visible = *this.get_ivar::<bool>("_visible");

                if visible {
                    // 1) punto en coordenadas de pantalla (Cocoa)
                    let screen_pt = NSPoint::new(sx, sy);
                    let screen_rect = NSRect::new(screen_pt, NSSize::new(0.0, 0.0));

                    // 2) pantalla -> ventana
                    let win: id = msg_send![this, window];
                    let win_rect: NSRect = msg_send![win, convertRectFromScreen: screen_rect];
                    let win_pt = win_rect.origin;

                    // 3) ventana -> vista
                    let view_pt: NSPoint = msg_send![this, convertPoint: win_pt fromView: nil];

                    // Dibujo centrado en view_pt (solo borde blanco, sin relleno)
                    let radius = CIRCLE_DIAMETER / 2.0;
                    let rect = NSRect::new(
                        NSPoint::new(view_pt.x - radius, view_pt.y - radius),
                        NSSize::new(CIRCLE_DIAMETER, CIRCLE_DIAMETER),
                    );

                    let ns_bezier = Class::get("NSBezierPath").unwrap();
                    let circle: id = msg_send![ns_bezier, bezierPathWithOvalInRect: rect];

                    let ns_color = Class::get("NSColor").unwrap();
                    let stroke: id = msg_send![ns_color, whiteColor];
                    let _: () = msg_send![stroke, set];
                    let _: () = msg_send![circle, setLineWidth: BORDER_WIDTH];
                    let _: () = msg_send![circle, stroke];
                }
            }
        }

        // Registro de métodos
        decl.add_method(sel!(update_cursor), update_cursor as extern "C" fn(&mut Object, Sel));
        decl.add_method(
            sel!(toggleVisibility),
            toggle_visibility as extern "C" fn(&mut Object, Sel),
        );
        decl.add_method(sel!(drawRect:), draw_rect as extern "C" fn(&Object, Sel, NSRect));

        // Registrar la clase
        decl.register()
    };

    // Crear instancia del tamaño de la ventana
    let view: id = msg_send![custom_view_class, alloc];
    let frame = NSRect::new(NSPoint::new(0.0, 0.0), NSSize::new(width, height));
    let view: id = msg_send![view, initWithFrame: frame];

    // Estado inicial
    (*view).set_ivar::<f64>("_cursorXScreen", 0.0);
    (*view).set_ivar::<f64>("_cursorYScreen", 0.0);
    (*view).set_ivar::<bool>("_visible", false);
    (*view).set_ivar::<id>("_keyMonitor", nil);

    // Añadir a la ventana (sin hacerla key)
    let _: () = msg_send![window, setContentView: view];

    view
}

/// Crea un NSTimer que llama `selector` en `target` cada `interval` segundos (~60 FPS)
unsafe fn create_timer(target: id, selector: Sel, interval: f64) -> id {
    let timer_class = Class::get("NSTimer").unwrap();
    let timer: id = msg_send![
        timer_class,
        scheduledTimerWithTimeInterval: interval
        target: target
        selector: selector
        userInfo: nil
        repeats: YES
    ];
    timer
}

/// Instala un monitor global para **teclado**; CTRL + A alterna visibilidad
unsafe fn install_global_key_monitor(view: id) {
    let mask: u64 = mask_from_event_type(NSEventType::NSKeyDown);

    let handler = ConcreteBlock::new(move |event: id| {
        unsafe {
            let key_code: u16 = msg_send![event, keyCode]; // 0 == 'A'
            let flags: u64 = msg_send![event, modifierFlags];
            // Control es el bit 1 << 18
            let ctrl_pressed = (flags & (1u64 << 18)) != 0;

            if key_code == 0 && ctrl_pressed {
                let _: () = msg_send![
                    view,
                    performSelectorOnMainThread: sel!(toggleVisibility)
                    withObject: nil
                    waitUntilDone: NO
                ];
            }
        }
    })
        .copy();

    let cls = class!(NSEvent);
    let monitor: id = msg_send![cls, addGlobalMonitorForEventsMatchingMask: mask handler: &*handler];
    if monitor != nil {
        // Retenemos el monitor en la vista para que no se libere
        (*view).set_ivar::<id>("_keyMonitor", monitor);
    } else {
        eprintln!("❌ Falta permiso de 'Monitorización de entradas' para el monitor de teclado.");
    }
}
